// --- Private Helper Functions ---

static void
print_uppercase( FILE* fp, const char* str )
{
    while ( *str )
    {
        print_fprintf( fp, "%c", char_to_upper( (unsigned char)*str ) );
        str++;
    }
}

// Maps a C type name to the name used for the cf_type_t variable.
static const char*
get_cf_type_name( const char* c_name )
{
    if ( str_cmp( c_name, "void" ) == 0 )
        return "void";
    if ( str_cmp( c_name, "bool" ) == 0 )
        return "bool";
    if ( str_cmp( c_name, "char" ) == 0 )
        return "char";
    if ( str_cmp( c_name, "int8_t" ) == 0 )
        return "i8";
    if ( str_cmp( c_name, "int16_t" ) == 0 )
        return "i16";
    if ( str_cmp( c_name, "int32_t" ) == 0 )
        return "i32";
    if ( str_cmp( c_name, "int64_t" ) == 0 )
        return "i64";
    if ( str_cmp( c_name, "uint8_t" ) == 0 )
        return "u8";
    if ( str_cmp( c_name, "uint16_t" ) == 0 )
        return "u16";
    if ( str_cmp( c_name, "uint32_t" ) == 0 )
        return "u32";
    if ( str_cmp( c_name, "uint64_t" ) == 0 )
        return "u64";
    if ( str_cmp( c_name, "float" ) == 0 )
        return "f32";
    if ( str_cmp( c_name, "double" ) == 0 )
        return "f64";
    if ( str_cmp( c_name, "const char*" ) == 0 )
        return "cstr";
    // If not a primitive, it's a user-defined type. The name is the same.
    return c_name;
}

static void
generate_h_file( FILE* fp, const parsed_data_t* data )
{
    print_fprintf( fp, "// THIS FILE IS-GENERATED BY CFLEX_BUILD. DO NOT EDIT.\n" );
    print_fprintf( fp, "#ifndef CFLEX_GENERATED_H\n" );
    print_fprintf( fp, "#define CFLEX_GENERATED_H\n\n" );
    print_fprintf( fp, "typedef enum cf_type_id_t {\n" );
    print_fprintf( fp, "    CF_TYPE_ID_VOID, CF_TYPE_ID_BOOL, CF_TYPE_ID_CHAR, CF_TYPE_ID_I8,\n" );
    print_fprintf( fp, "    CF_TYPE_ID_I16, CF_TYPE_ID_I32, CF_TYPE_ID_I64, CF_TYPE_ID_U8,\n" );
    print_fprintf( fp, "    CF_TYPE_ID_U16, CF_TYPE_ID_U32, CF_TYPE_ID_U64, CF_TYPE_ID_F32,\n" );
    print_fprintf( fp, "    CF_TYPE_ID_F64, CF_TYPE_ID_CSTR,\n" );

    for ( int i = 0; i < data->num_types; ++i )
    {
        print_fprintf( fp, "    CF_TYPE_ID_" );
        print_uppercase( fp, data->types[ i ].name );
        print_fprintf( fp, ",\n" );
    }

    print_fprintf( fp, "    CF_TYPE_ID_COUNT\n" );
    print_fprintf( fp, "} cf_type_id_t;\n\n" );
    print_fprintf( fp, "#endif // CFLEX_GENERATED_H\n" );
}

static void
generate_c_file( FILE* fp, const parsed_data_t* data, const file_list_t* headers )
{
    print_fprintf( fp, "// THIS FILE IS-GENERATED BY CFLEX_BUILD. DO NOT EDIT.\n" );
    print_fprintf( fp, "#include \"cflex.h\"\n" );
    print_fprintf( fp, "#include <stddef.h>\n" );

    for ( int i = 0; i < headers->count; ++i )
    {
        // const char* filename = str_rchr(headers->files[i], '/');
        // if (!filename) filename = str_rchr(headers->files[i], '\\');
        const char* filename = str_rchr( headers->files[ i ], '\\' );
        filename             = filename ? filename + 1 : headers->files[ i ];
        print_fprintf( fp, "#include \"%s\"\n", filename );
    }
    print_fprintf( fp, "\n" );

    // Primitives
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_void = { .name = \"void\", .kind = CF_KIND_PRIMITIVE, .size = 0, .align = 0, .prim = CF_PRIM_VOID };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_bool = { .name = \"bool\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(bool), .align = _Alignof(bool), .prim = CF_PRIM_BOOL };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_char = { .name = \"char\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(char), .align = _Alignof(char), .prim = CF_PRIM_CHAR };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_i8 = { .name = \"int8_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(int8_t), .align = _Alignof(int8_t), .prim = CF_PRIM_I8 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_i16 = { .name = \"int16_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(int16_t), .align = _Alignof(int16_t), .prim = CF_PRIM_I16 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_i32 = { .name = \"int32_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(int32_t), .align = _Alignof(int32_t), .prim = CF_PRIM_I32 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_i64 = { .name = \"int64_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(int64_t), .align = _Alignof(int64_t), .prim = CF_PRIM_I64 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_u8 = { .name = \"uint8_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint8_t), .align = _Alignof(uint8_t), .prim = CF_PRIM_U8 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_u16 = { .name = \"uint16_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint16_t), .align = _Alignof(uint16_t), .prim = CF_PRIM_U16 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_u32 = { .name = \"uint32_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint32_t), .align = _Alignof(uint32_t), .prim = CF_PRIM_U32 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_u64 = { .name = \"uint64_t\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint64_t), .align = _Alignof(uint64_t), .prim = CF_PRIM_U64 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_f32 = { .name = \"float\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(float), .align = _Alignof(float), .prim = CF_PRIM_F32 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_f64 = { .name = \"double\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(double), .align = _Alignof(double), .prim = CF_PRIM_F64 };\n" );
    print_fprintf(
        fp,
        "static const cf_type_t cf_type_cstr = { .name = \"const char*\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(const char*), .align = _Alignof(const char*), .prim = CF_PRIM_CSTR };\n\n" );

    // User types
    for ( int i = 0; i < data->num_types; ++i )
    {
        const parsed_type_t* type = &data->types[ i ];
        if ( type->kind == PARSED_KIND_STRUCT )
        {
            print_fprintf( fp, "static const cf_field_t cf_%s_fields[] = {\n", type->name );
            for ( int j = 0; j < type->struct_info.num_fields; ++j )
            {
                const parsed_field_t* field        = &type->struct_info.fields[ j ];
                const char*           cf_type_name = get_cf_type_name( field->type_name );
                print_fprintf( fp, "    { \"%s\", &cf_type_%s, offsetof(%s, %s), 0 },\n", field->name, cf_type_name,
                         type->name, field->name );
            }
            print_fprintf( fp, "};\n" );
            print_fprintf(
                fp,
                "static const cf_type_t cf_type_%s = { .name = \"%s\", .kind = CF_KIND_STRUCT, .size = sizeof(%s), .align = _Alignof(%s), .struct_array = cf_%s_fields, .struct_count = %d, .struct_parent = NULL, .struct_is_anonymous = false };\n\n",
                type->name, type->name, type->name, type->name, type->name, type->struct_info.num_fields );
        }
        else if ( type->kind == PARSED_KIND_ENUM )
        {
            print_fprintf( fp, "static const cf_enum_value_t cf_%s_values[] = {\n", type->name );
            for ( int j = 0; j < type->enum_info.num_values; ++j )
            {
                const parsed_enum_value_t* value = &type->enum_info.values[ j ];
                print_fprintf( fp, "    { \"%s\", %s },\n", value->name, value->name );
            }
            print_fprintf( fp, "};\n" );
            print_fprintf(
                fp,
                "static const cf_type_t cf_type_%s = { .name = \"%s\", .kind = CF_KIND_ENUM, .size = sizeof(%s), .align = _Alignof(%s), .enum_array = cf_%s_values, .enum_count = %d, .enum_is_bitflag = false };\n\n",
                type->name, type->name, type->name, type->name, type->name, type->enum_info.num_values );
        }
    }

    // Global type array
    print_fprintf( fp, "const cf_type_t* cf_type_array[] = {\n" );
    print_fprintf(
        fp,
        "    &cf_type_void, &cf_type_bool, &cf_type_char, &cf_type_i8, &cf_type_i16, &cf_type_i32, &cf_type_i64, &cf_type_u8, &cf_type_u16, &cf_type_u32, &cf_type_u64, &cf_type_f32, &cf_type_f64, &cf_type_cstr,\n" );
    for ( int i = 0; i < data->num_types; ++i )
    {
        print_fprintf( fp, "    &cf_type_%s,\n", data->types[ i ].name );
    }
    print_fprintf( fp, "};\n" );
    print_fprintf( fp, "const int32_t cf_type_count = sizeof(cf_type_array) / sizeof(cf_type_array[0]);\n" );
}


// --- Public API ---

bool
generate_output_files( const char* output_path, const parsed_data_t* data, const file_list_t* headers )
{
    char h_path[ MAX_PATH_LENGTH ];
    char c_path[ MAX_PATH_LENGTH ];
    print_snprintf( h_path, sizeof( h_path ), "%s/cflex_generated.h", output_path );
    print_snprintf( c_path, sizeof( c_path ), "%s/cflex_generated.c", output_path );

    FILE* fp_h = fopen( h_path, "w" );
    if ( !fp_h )
    {
        print_fprintf( stderr, "Error: Could not open file for writing: %s\n", h_path );
        return false;
    }
    generate_h_file( fp_h, data );
    fclose( fp_h );
    print_printf( "Generated %s\n", h_path );

    FILE* fp_c = fopen( c_path, "w" );
    if ( !fp_c )
    {
        print_fprintf( stderr, "Error: Could not open file for writing: %s\n", c_path );
        return false;
    }
    generate_c_file( fp_c, data, headers );
    fclose( fp_c );
    print_printf( "Generated %s\n", c_path );

    return true;
}
