/*==============================================================================================

    Output

==============================================================================================*/

static void
print_uppercase( FILE* fp, const char* str )
{
    while ( *str )
    {
        file_print_fmt( fp, "%c", char_to_upper( (unsigned char)*str ) );
        str++;
    }
}

/*============================================================================================*/

// Maps a C type name to the name used for the cf_type_t variable.
static const char*
get_cf_type_name( const char* c_name )
{
    // clang-format off
    if ( str_cmp( c_name, "void" ) == 0 ) return "void";
    if ( str_cmp( c_name, "bool" ) == 0 ) return "bool";
    if ( str_cmp( c_name, "char" ) == 0 ) return "char";
    if ( str_cmp( c_name, "int8_t" ) == 0 ) return "i8";
    if ( str_cmp( c_name, "int16_t" ) == 0 ) return "i16";
    if ( str_cmp( c_name, "int32_t" ) == 0 ) return "i32";
    if ( str_cmp( c_name, "int64_t" ) == 0 ) return "i64";
    if ( str_cmp( c_name, "uint8_t" ) == 0 ) return "u8";
    if ( str_cmp( c_name, "uint16_t" ) == 0 ) return "u16";
    if ( str_cmp( c_name, "uint32_t" ) == 0 ) return "u32";
    if ( str_cmp( c_name, "uint64_t" ) == 0 ) return "u64";
    if ( str_cmp( c_name, "float" ) == 0 ) return "f32";
    if ( str_cmp( c_name, "double" ) == 0 ) return "f64";
    if ( str_cmp( c_name, "const char*" ) == 0 ) return "cstr";
    // clang-format on

    return c_name; // If not a primitive, it's a user-defined type. The name is the same.
}

/*============================================================================================*/

// Generates the content of the `<module_name>_generated.h` file.
static void
generate_h_file( FILE* fp, const char* module_name, bool default_types_only, const parsed_data_t* data )
{
    UNUSED(data);
    file_print_fmt( fp, "// THIS FILE IS-GENERATED BY CFLEX_BUILD. DO NOT EDIT.\n" );
    file_print_fmt( fp, "#ifndef " );
    print_uppercase( fp, module_name );
    file_print_fmt( fp, "_GENERATED_H\n" );
    file_print_fmt( fp, "#define " );
    print_uppercase( fp, module_name );
    file_print_fmt( fp, "_GENERATED_H\n\n" );

    file_print_fmt( fp, "#include \"cflex.h\"\n\n" );

    if ( !default_types_only )
    {
        file_print_fmt( fp, "#include \"cflex_default_generated.h\"\n\n" );
    }

    if ( default_types_only )
    {
        // clang-format off
        file_print_fmt( fp, "extern const cf_type_t cf_type_void;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_bool;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_char;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_i8;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_i16;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_i32;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_i64;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_u8;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_u16;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_u32;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_u64;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_f32;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_f64;\n" );
        file_print_fmt( fp, "extern const cf_type_t cf_type_cstr;\n\n" );
        // clang-format on
    }

    file_print_fmt( fp, "void %s_register_types(void);\n\n", module_name );
    file_print_fmt( fp, "#endif // " );
    print_uppercase( fp, module_name );
    file_print_fmt( fp, "_GENERATED_H\n" );
}

/*============================================================================================*/

// Generates the content of the `<module_name>_generated.c` file.
static void
generate_c_file( FILE*           fp,
                 const char*     module_name,
                 bool            default_types_only,
                 const parsed_data_t* data,
                 const file_list_t*   headers )
{
    file_print_fmt( fp, "// THIS FILE IS-GENERATED BY CFLEX_BUILD. DO NOT EDIT.\n" );
    file_print_fmt( fp, "#include \"internal/cflex_internal.h\"\n" );
    file_print_fmt( fp, "#include \"%s_generated.h\"\n", module_name );
    file_print_fmt( fp, "#include <stddef.h>\n\n" );

    if ( !default_types_only )
    {
        for ( int i = 0; i < headers->count; ++i )
        {
            const char* filename = str_rchr( headers->files[ i ], '/' );
            if ( !filename )
                filename = str_rchr( headers->files[ i ], '\\' );
            filename = filename ? filename + 1 : headers->files[ i ];
            file_print_fmt( fp, "#include \"%s\"\n", filename );
        }
        file_print_fmt( fp, "\n" );
    }

    if ( default_types_only )
    {
        // clang-format off
        file_print_fmt( fp, "const cf_type_t cf_type_void = { .name = \"void\",        .kind = CF_KIND_PRIMITIVE, .size = 0,                   .align = 0,                     .prim = CF_PRIM_VOID };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_bool = { .name = \"bool\",        .kind = CF_KIND_PRIMITIVE, .size = sizeof(bool),        .align = _Alignof(bool),        .prim = CF_PRIM_BOOL };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_char = { .name = \"char\",        .kind = CF_KIND_PRIMITIVE, .size = sizeof(char),        .align = _Alignof(char),        .prim = CF_PRIM_CHAR };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_i8   = { .name = \"int8_t\",      .kind = CF_KIND_PRIMITIVE, .size = sizeof(int8_t),      .align = _Alignof(int8_t),      .prim = CF_PRIM_I8 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_i16  = { .name = \"int16_t\",     .kind = CF_KIND_PRIMITIVE, .size = sizeof(int16_t),     .align = _Alignof(int16_t),     .prim = CF_PRIM_I16 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_i32  = { .name = \"int32_t\",     .kind = CF_KIND_PRIMITIVE, .size = sizeof(int32_t),     .align = _Alignof(int32_t),     .prim = CF_PRIM_I32 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_i64  = { .name = \"int64_t\",     .kind = CF_KIND_PRIMITIVE, .size = sizeof(int64_t),     .align = _Alignof(int64_t),     .prim = CF_PRIM_I64 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_u8   = { .name = \"uint8_t\",     .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint8_t),     .align = _Alignof(uint8_t),     .prim = CF_PRIM_U8 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_u16  = { .name = \"uint16_t\",    .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint16_t),    .align = _Alignof(uint16_t),    .prim = CF_PRIM_U16 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_u32  = { .name = \"uint32_t\",    .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint32_t),    .align = _Alignof(uint32_t),    .prim = CF_PRIM_U32 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_u64  = { .name = \"uint64_t\",    .kind = CF_KIND_PRIMITIVE, .size = sizeof(uint64_t),    .align = _Alignof(uint64_t),    .prim = CF_PRIM_U64 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_f32  = { .name = \"float\",       .kind = CF_KIND_PRIMITIVE, .size = sizeof(float),       .align = _Alignof(float),       .prim = CF_PRIM_F32 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_f64  = { .name = \"double\",      .kind = CF_KIND_PRIMITIVE, .size = sizeof(double),      .align = _Alignof(double),      .prim = CF_PRIM_F64 };\n" );
        file_print_fmt( fp, "const cf_type_t cf_type_cstr = { .name = \"const char*\", .kind = CF_KIND_PRIMITIVE, .size = sizeof(const char*), .align = _Alignof(const char*), .prim = CF_PRIM_CSTR };\n\n" );
        // clang-format on
    }
    else
    {
        for ( int i = 0; i < data->num_types; ++i )
        {
            const parsed_type_t* type = &data->types[ i ];
            if ( type->kind == PARSED_KIND_STRUCT )
            {
                file_print_fmt( fp, "static const cf_field_t cf_%s_%s_fields[] = {\n", module_name, type->name );
                for ( int j = 0; j < type->struct_info.num_fields; ++j )
                {
                    const parsed_field_t* field        = &type->struct_info.fields[ j ];
                    const char*           cf_type_name = get_cf_type_name( field->type_name );
                    file_print_fmt( fp, "    { \"%s\", &cf_type_%s, offsetof(%s, %s), 0 },\n", field->name,
                                    cf_type_name, type->name, field->name );
                }
                file_print_fmt( fp, "};\n" );
                file_print_fmt(
                    fp,
                    "static const cf_type_t cf_type_%s = { .name = \"%s\", .kind = CF_KIND_STRUCT, .size = sizeof(%s), .align = _Alignof(%s), .struct_array = cf_%s_%s_fields, .struct_count = %d, .struct_parent = NULL, .struct_is_anonymous = false };\n\n",
                    type->name, type->name, type->name, type->name, module_name, type->name,
                    type->struct_info.num_fields );
            }
            else if ( type->kind == PARSED_KIND_ENUM )
            {
                file_print_fmt( fp, "static const cf_enum_value_t cf_%s_%s_values[] = {\n", module_name, type->name );
                for ( int j = 0; j < type->enum_info.num_values; ++j )
                {
                    const parsed_enum_value_t* value = &type->enum_info.values[ j ];
                    file_print_fmt( fp, "    { \"%s\", %d },\n", value->name, value->value );
                }
                file_print_fmt( fp, "};\n" );
                file_print_fmt(
                    fp,
                    "static const cf_type_t cf_type_%s = { .name = \"%s\", .kind = CF_KIND_ENUM, .size = sizeof(%s), .align = _Alignof(%s), .enum_array = cf_%s_%s_values, .enum_count = %d, .enum_is_bitflag = false };\n\n",
                    type->name, type->name, type->name, type->name, module_name, type->name,
                    type->enum_info.num_values );
            }
        }
    }

    if ( ( default_types_only ) || ( data->num_types > 0 ) )
    {
        file_print_fmt( fp, "static const cf_type_t* %s_type_array[] = {\n", module_name );
        if ( default_types_only )
        {
            file_print_fmt(
                fp,
                "    &cf_type_void, &cf_type_bool, &cf_type_char, &cf_type_i8, &cf_type_i16, &cf_type_i32, &cf_type_i64, &cf_type_u8, &cf_type_u16, &cf_type_u32, &cf_type_u64, &cf_type_f32, &cf_type_f64, &cf_type_cstr\n" );
        }
        else
        {
            for ( int i = 0; i < data->num_types; ++i )
            {
                file_print_fmt( fp, "    &cf_type_%s,\n", data->types[ i ].name );
            }
        }
        file_print_fmt( fp, "};\n" );
        file_print_fmt( fp, "static const int32_t %s_type_count = sizeof(%s_type_array) / sizeof(%s_type_array[0]);\n\n",
                        module_name, module_name, module_name );
    }
    else
    {
        file_print_fmt( fp, "static const cf_type_t** %s_type_array = NULL;\n", module_name );
        file_print_fmt( fp, "static const int32_t %s_type_count = 0;\n\n", module_name );
    }

    file_print_fmt( fp, "void %s_register_types(void) {\n", module_name );
    file_print_fmt( fp, "    cf_register_type_table(%s_type_array, %s_type_count);\n", module_name, module_name );
    file_print_fmt( fp, "}\n" );
}

/*============================================================================================*/

bool
generate_output_files( const char*      output_path,
                       const char*      module_name,
                       bool             default_types_only,
                       const parsed_data_t* data,
                       const file_list_t*   headers )
{
    char h_path[ MAX_PATH_LENGTH ];
    char c_path[ MAX_PATH_LENGTH ];
    str_print_fmt( h_path, sizeof( h_path ), "%s/%s_generated.h", output_path, module_name );
    str_print_fmt( c_path, sizeof( c_path ), "%s/%s_generated.c", output_path, module_name );

    FILE* fp_h = fopen( h_path, "w" );
    if ( !fp_h )
    {
        file_print_fmt( stderr, "Error: Could not open file for writing: %s\n", h_path );
        return false;
    }
    generate_h_file( fp_h, module_name, default_types_only, data );
    fclose( fp_h );
    print_fmt( "Generated %s\n", h_path );

    FILE* fp_c = fopen( c_path, "w" );
    if ( !fp_c )
    {
        file_print_fmt( stderr, "Error: Could not open file for writing: %s\n", c_path );
        return false;
    }
    generate_c_file( fp_c, module_name, default_types_only, data, headers );
    fclose( fp_c );
    print_fmt( "Generated %s\n", c_path );

    return true;
}

/*============================================================================================*/